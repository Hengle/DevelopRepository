シェーダ勉強会用資料 - 冒頭30分用

【はじめに】
■企画側がこの勉強会に参加する意義
・「Unityというソフト上で、テクスチャやモデルがどう表示されているか」
の根本をざっくりでも知ることで、エンジニアとのやりとりがスムーズになります

・また、おおよその原理が分かれば「モデル側で対応が必要かも」だったり、
「板ポリ（テクスチャ）で十分表現可能だな」といったアタリが付けられ、
素材を用意する際の一助にもなります

・シェーダをお勉強、ではなく、「素材がどうやって描画されるか」に重点をおいて
説明していきます


【基礎編】

■ゲームに使用される主な素材
・テクスチャ ... いわゆる画像データ
・モデル ... 3DCGツールで制作されたポリゴンデータ
・その他 ... BGM/SEなど

今回は主にテクスチャについてお話しします。
（なぜなら3Dも原理的には同じ処理によって描画されているからです）


■Unityで素材を描画するのに必要な３大要素
・ポリゴン
・シェーダ
・マテリアル

これらは一つでも欠ければ描画されません。


■2次元的 と 3次元的 を分ける境界となる要素
・影
・奥行き

・「カメラ」と定義されたオブジェクトから、
・様々な計算を経て3次元の空間に表示され、
・それがデバイス上（2次元の平面）に投影、描画されます。


■テクスチャをUnity上に表示するには？
・テクスチャをProjectに配置（この段階ではただフォルダに突っ込んだだけ）
・Inspector上で「Default」から「Sprite」へ変更
・ProjectからHierarchyにドラッグアンドドロップ

一般的にはこれだけで描画されます。


■実際に内部で行われていること - ざっくり
・HierarchyにD&Dされると、自動的に板ポリが生成される
・SpriteRendererという「コンポーネント」が適用される
・そのコンポーネントに、自動的に「Sprite-Default」というマテリアルが適用される
・それによって「Sprite-Default」シェーダが稼働し、画面上に描画される
 → この「シェーダ」が実際に描画処理を担当
 → 上述した３大要素が、このアクションだけで全て実行されている

つまり「2Dだから簡単、3Dだから難しい」ということはありません。
ごく単純に、3Dっぽく見せる（演出する）ために必要な要素が、
2Dの一枚絵を置くよりも複雑である、というだけです。


■シェーダを変えると見た目がどう変わるのか？
・実演します


■まとめ
・最終的には全て「色が表示されているだけ」という認識をもつ
・「テクスチャ」が直接ゲーム上に表示されているわけではない
・Unityによって様々なことが隠蔽、処理されて描画されている
・描画自体を行っているのが「シェーダ」
・素材（テクスチャ、モデル）を料理（シェーディング）し、
結果を2次元上のピクセルに描画している
・2Dも3Dも、Unity上では等しくモデルとして扱われている
・つまり「2Dで出来ることは3Dでも出来る」し、「3Dで出来ることは2Dでも擬似的に可能」
・よく演出で使うパーティクルエフェクトも、ただの板ポリ（ビルボード）を生成してるだけ


■素材を扱う上で知っておいて欲しいこと
・テクスチャは2の累乗で
 → 素の状態のテクスチャを使うことはまずありません
 → 必ず「圧縮」を行い、メモリ使用量を削減して使用します
 → 「2の累乗でないと圧縮処理が働かない」ので、必ず上記のルールを守ってください
 → 納まりきらない場合は一つ上の乗数で問題ありません
 → エンジニア側は↑に対応するため、テクスチャアトラス化することを推奨します
 
・「動的に表現する」ものは処理負荷が高く、「静的に表現する」ものは負荷が低い
 → 影やオブジェクト生成などの動的処理 ... 高負荷
 → 最初からシーン上に配置、動かさないマップ ... 低負荷

・同様に、「ゲーム的な動きをさせる」ことは性質上楽に実装できますが、
「○○の動きをシミュレートする」のは制作コストが高くつく傾向にあります
 → 流体の動き、モデル自体を生成/破壊する行為等
 → CGの企画の皆さんはこの辺り「ソレっぽく作れてればOK！」と言ってくれますが、
    まさしくそれ以上のことをしようとするとコストがかかるのです
 → とはいえゲームの面白さに直結する部分はしっかり作るべきなので、
    「コアとなる部分」に工数をかけ、逐次状況をエンジニアと共有しあって進めるのが
    ベターだと思います





シェーダ勉強会用資料 - エンジニア用


【はじめに】
■勉強会の目的
・「シェーダっていうのを弄れば見た目が変わるんだな」だったり、
  「マテリアルに設定して、C#からアクセス出来るんだな」といった、
  "どういうものかふわっと知っているけど、中でどう処理しているのかはよく分からない"
  といった人が対象です

・本学習の目的は「レベル２をレベル７に上げる」ことです。
  従って、数学的で複雑な計算について教えることはありません
  （むしろ今の段階でそれは不要だと思います）

・基本のキ を知ることで、今後難しい実装が必要になったときでも
  「要はこういうことをしてるんだな」と鼻が効くようになる。
  そうなることを目標に進めていきます



【基礎編】
■3Dにおけるレンダリングの構成
・入力 ... モデルデータの指定
・頂点シェーダ ... 座標変換、陰影処理、テクスチャ座標指定
・ラスタライズ ... ポリゴンをレンダリング、対象のピクセルに反映
・ピクセルシェーダ ... 画像の色情報の反映
・出力 ... レンダリング

※これら全ての処理を行うのがUnityのシェーダファイル。
入力〜出力までの全体の流れを「レンダリングパイプライン」と呼ぶ


■座標変換 - 3Dから2Dへ
・モデルの持つ座標(モデル座標)にMVP行列を掛けることで、カメラから見た描画位置を確定させる
・モデル行列M = モデルのローカル座標をワールド座標に変換するもの
・ビュー行列V = ワールド座標からカメラの座標に変換するもの
・プロジェクション行列P = カメラの座標を投影座標に変換するもの
・これらをモデル座標に掛けて変換を行うのが「頂点シェーダ」
 → mul(UNITY_MATRIX_MVP, vertex);
 → 現在は UnityObjectToClipPos(vertex);


■ラスタライズ - ピクセルデータ生成
・計算された頂点を元に、点と点の間にピクセルデータを生成する
・ここで生成されるピクセルデータの数はゲーム画面の解像度に比例
・つまり解像度が高ければ高いほど計算対象となるピクセルデータが多くなり、負荷が高まる
・頂点シェーダからフラグメントシェーダへ値を受け渡すときに勝手に処理される


■カリング - いわゆる「隠面消去」
・出来上がった面のうち、手前の面だけを表示し、隠れた面(裏面)は計算をスキップする
・これにより無駄な計算を省く
・通常は裏面が表示されないようになっている(バックフェースカリング)


■描画順に関して
・Unityの描画は一般的なCGの描画と同じく、Zバッファ(深度バッファ)によって管理される
・その中で、個々の深度設定(描画順)はシェーダのRenderQueueにて定義される
・RenderQueueは大きく「不透明」と「半透明」の二種類に分類される

・不透明オブジェクト
 → 一般的には「カメラの手前から順に描画」される (デフォルト設定だと)
 → 一度描画されたピクセルをスキップして効率的に描画するために、手前から描画される
 → Zバッファの値によって前後関係が決まるため、崩れが起きない
 
・半透明オブジェクト
 → こちらは「カメラの奥から順に描画」される
 → 半透明の仕組み上「奥にある色とのブレンド」が必要になり、
    Zバッファに予め書き込まれていないと破綻するため


■ピクセルシェーダ
・ラスタライザから受け取ったピクセルデータ一つ一つに色を付ける工程
・これを行うのが「フラグメントシェーダ(ピクセルシェーダ)」
・視線や光源等の情報からライティングの計算を行ったり、
  テクスチャデータからUVを元にテクセルをフェッチしてその色を描画したりする
・見た目に関する部分は多くがこの工程で行われる


■サーフェイスシェーダ
・ライティングするには、複雑な計算を自前で行う必要がある
・その手間を省くため(より汎用的に扱うため)、Unity側で用意したものがサーフェイスシェーダ
・光源からの影響を受けたいときはこのシェーダを定義し実装するのが楽
※ただし、「中で何をやっているのか理解する」ことが今回の目的なので、
  勉強会中はサーフェイスシェーダは使いません


■ポストプロセッシング
・各オブジェクトのシェーダによって打たれたピクセル(色)を、
  一枚のテクスチャと捉えて加工を行う工程
・全体の見栄えを変えるような特殊効果を与える場合に使用される
・性質上、「カメラにレンダリングされているオブジェクト」が対象



【Unity基礎編】

■そもそもどういうときにシェーダを書くべきなのか？
・リッチな見栄えにしたいとき
・元絵をスクリプト側から制御したいとき
・CPUバウンドな状態で、少しでもGPUに処理を任せたいとき


■具体的にどんな場面？
・単体のモデルで完結させたいとき
 → 例えば「水流」を作るとする
 → ParticleSystemで水テクスチャを引き伸ばして30個ほどEmitさせればそれっぽくなる
 → それに対し、円筒のモデルを一つ用意して水テクスチャをUVスクロールさせても良い
 → ビルボードのテクスチャを30個生成する vs 1つのテクスチャ＋モデルで表現
 → 後者の方がコスト的に安くつく
 
・いわゆる「特殊効果」を扱いたいとき
 → マスキング、ディゾルブ、ディストーション、ステンシル、etc..
 
・逆に「シェーダを使わない」描画は無いので、いつでも使うとも言える
・単なる表示/非表示のようなもの、C#側で対応可能なものはそちらでもOK


■使用例
・SSRカードを「キラッ」とさせたい！
 → 光の線画像を用意し、対象テクスチャの上に加算
 → それを一定間隔でUVスクロール
 
・キャラクターに入れ墨を入れたい！
 → 入れたい部分のシェーダを拡張し、デカール的にテクスチャを貼り付ける
 
・海を表現したい！
 → 水の表面テクスチャを作成し、シェーダでUVスクロールする
 → 「波の感じを出したい」なら、頂点シェーダで波っぽい計算(sin等)を行い、
    それを各頂点に適用する
    
・キャラがオブジェクトで隠れてしまう！後ろにある部分を可視化したい
 → 隠す側のシェーダでステンシルバッファに書き込み、キャラ側はそれを見て
    書き込まれている部分には単色を表示するようなシェーダを書く
    
・魔法少女を変身させたい！
 → 元の服テクスチャと別に、変身後のテクスチャを参照出来るようなシェーダを書く
 → しきい値を外部化し、しきい値よりYが高い部分は変身後、低い部分は変身前のテクスチャから
    テクセルをフェッチして色塗り
 → しきい値の部分がスッパリして見えるので、その位置に適当な光テクスチャを加算してごまかす
 
・ゲーム中でライティングが不要なのでライト消したら、
  アセットストアから落としたPrefabが暗くなったんだが・・
 → 光源計算を使用するシェーダなのでそうなる
 → Unlitなシェーダを新規に作り、UVに応じてテクスチャだけ貼って終わり
 → それでも影を表現したければ、擬似的に足元に丸影おいたり、影用のモデルを作って
    それにだけ光源計算かけちゃうとか

・すりガラスっぽい見た目にしたい！
 → 対象ピクセルの周辺にあるピクセルから色をフェッチし、ブレンドすることで平滑化を行う
 → すると見た目のメリハリが薄くなることから、ぼやけたような見え方になる
 → 詳しくはガウスぼかしで検索


■頻出ワード
・マップ
 → 法線マップや、「〇〇をマップして〜」といったものに使われる
 → 「一対一で対応したもの、関連したもの」という認識でOK
 → マップの黒い部分は色を濃く〜といった具合
 
・バッファ
 → 頂点バッファ、インデックスバッファ、Zバッファ、ステンシルバッファといったものに使われる
 → データを一時的に格納するためのメモリ領域のこと
 → 「ステンシルバッファに1で書き込んでおき、次のシェーダで
    ステンシルバッファが1以上だったら〜を行う」といった感じで使用する
 → ドットでイメージすると分かりやすいかも


番外: そもそもUnityってどうやってSpriteを表示しているのか？
・テクスチャをシーン上にペッと移動させると、空間上に勝手に配置される
・SpriteRendererからカラーを設定すると、そのカラーがテクスチャに乗算される
・Unityが裏で勝手にやってくれているのが、
 → メッシュ(Quad)の作成
 → デフォルトのSpriteマテリアルの設定
 → 頂点カラーの設定
 → シェーダでの頂点カラーの乗算






